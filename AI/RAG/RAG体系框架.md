# RAG体系框架

先说一句狠话，如果你觉得 RAG 是：

- 向量库 + Embedding

- 检索几段文本 + 丢给 LLM
- 能跑就行

那你现在看到的大多数 RAG 系统，在规模一上来时，都会失效。不是模型不行，是结构没搭完。

而这张图，讲的就是：一个 RAG 系统，从“能用”，到“可扩展、可评估、可演化”，到底需要哪些结构层。

![img](https://i-blog.csdnimg.cn/img_convert/3f45fa66f19f482a4df13c4ec632a0a0.jpeg)

## 第一层：数据不是从“文本”开始的

很多人一上来就聊向量库，其实顺序是反的。

真正的起点在最底部：数据导入与文本分块。

你会看到这里不是一句“切 chunk”，而是：

- 按字符 / 句子 / 语义的分块策略
- 父子文档索引
- 分层索引（RAPTOR）
- 多表示索引

为什么？

因为检索失败，80% 不是检索算法的问题，是切块阶段就已经丢信息了。

如果你在这一层没有“结构意识”，后面所有高级技巧，都是在补锅。



## 第二层：Embedding 从来不是一个模型的问题
中间这一大块，是很多人最容易误解的地方。

Embedding 不是只有一个向量。

你会看到：

- 稠密向量（OpenAI / bge / jina）
- 稀疏向量（TF-IDF / BM25）
- 专用嵌入（Fine-Tuning / ColBERT）



为什么要这么复杂？

因为现实世界的检索，本来就不是一个相似度空间。

关键词、语义、领域信号，本来就不在同一个空间里。

真正可用的系统，一定是混合表示。



## 第三层：索引与向量库只是"物理层"
很多人把 FAISS、Milvus、HNSW 当成核心。

但在这张图里，它们被刻意画得很“靠后”。

因为它们解决的只是一个问题：`怎么快`，而不是：`怎么对`

**索引策略（父子、分层、多表示），远比你选哪种向量库重要。**



## 第四层：真正开始像"系统"的地方--查询侧
图左上角，是整个系统的灵魂。

你会看到四件事同时出现：

1. 查询构建
2. 查询优化
3. 查询路由
4. HyDE / 主动检索

这一步意味着什么？

意味着系统已经不再是：

> 用户问一句，我搜一遍

而是：

> 系统开始“理解该怎么问世界



## 第五层：检索后处理，决定答案质量上限

中间偏右那一块，是很多Demo系统里完全没有的东西。

- 重排（Rerank / Cross-Encoder / ColBERT）
- 压缩（相关性 + 冗余控制）
- 校正（CRAG）
- 主动补查

这一层解决的是：

> **不是有没有搜到，而是“哪些值得被看见”。**

如果没有这一层，

你永远会觉得：“有点对，但总差点意思”。



## 第六层：生成不只是“丢给模型”

右下角的生成部分，刻意没有画成一个大脑就结束。

你会看到：

- 提示工程
- 结构化输出（Pydantic / JSON Schema）
- 工具调用
- Self-RAG / RRR
- 主动再检索

这意味着一件事：

> **生成，本身也是一个可以被设计、被反思的过程。**



## 第七层：评估，是系统是否“工程化”的分水岭

最右侧那一列，是很多人最不想做、但最重要的。

- Precision / Recall / F1
- MRR / MAP
- BLEU / ROUGE / METEOR
- 忠实度 / 安全性

有没有这一列，决定了：

> 你是在做 Demo，
> 还是在做系统。



# 参考

书籍：

《RAG实战课》



“结构没搭完“你的RAG就废了！7层架构图带你从入门到大神，小白程序员也能秒懂大模型检索增强生成

https://blog.csdn.net/m0_59164520/article/details/156610737



MCP & A2A前言实战

https://time.geekbang.org/column/article/882188

